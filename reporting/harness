#!/usr/bin/perl
#
# Lintian reporting harness -- Create and maintain Lintian reports automatically
#
# Copyright (C) 1998 Christian Schwarz and Richard Braakman
#
# This program is free software.  It is distributed under the terms of
# the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

use strict;
use warnings;

use constant BACKLOG_PROCESSING_GROUP_LIMIT => 1024;
use constant BACKLOG_PROCESSING_TIME_LIMIT => 4 * 3600; # 4hours

use Date::Format qw(time2str);
use Errno qw(ENOENT);
use Fcntl qw(F_GETFD F_SETFD FD_CLOEXEC);
use File::Temp qw(tempfile);
use Getopt::Long;
use POSIX qw(strftime);
use YAML::Any();

sub usage {
    print <<END;
Lintian reporting harness
Create and maintain Lintian reports automatically

Usage: harness [ -i | -f | -r | -c ]

Options:
  -c         clean mode, erase everything and start from scratch (implies -f)
  -f         full mode, blithely overwrite lintian.log
  -i         incremental mode, use old lintian.log data, process changes only
  -r         generate HTML reports only
  --dry-run  pretend to do the actions without actually doing them.  The
             "normal" harness output will go to stdout rather than the
             harness.log.
  --to-stdout
             [For debugging] Have output go to stdout as well as the usual
             log files.  Note, this option has no (extra) effect with --dry-run.
  --schedule-chunk-size N
             Schedule at most N groups in a given run of Lintian.  If more than N
             groups need to be processed, harness will invoke Lintian more than
             once.  If N is 0, schedule all groups in one go.  (Default: 512)

Incremental mode is the default if you have a lintian.log;
otherwise, it's full.

Report bugs to <lintian-maint\@debian.org>.
END
    #'# for cperl-mode
    exit;
}

my $LOG_FD;
my %opt = ('schedule-chunk-size' => 512,);

my %opthash = (
    'i' => \$opt{'incremental-mode'},
    'c' => \$opt{'clean-mode'},
    'f' => \$opt{'full-mode'},
    'r' => \$opt{'reports-only'},
    'dry-run' => \$opt{'dry-run'},
    'schedule-chunk-size=i' => \$opt{'schedule-chunk-size'},
    'to-stdout' => \$opt{'to-stdout'},
    'help|h' => \&usage,
);

# init commandline parser
Getopt::Long::config('bundling', 'no_getopt_compat', 'no_auto_abbrev');

# process commandline options
GetOptions(%opthash)
  or die("error parsing options\n");

# clean implies full - do this as early as possible, so we can just
# check $opt{'full-mode'} rather than a full
#   ($opt{'clean-mode'} || $opt{'full-mode'})
$opt{'full-mode'} = 1 if $opt{'clean-mode'};

die "Cannot use both incremental and full/clean.\n"
  if $opt{'incremental-mode'} && $opt{'full-mode'};
die "Cannot use other modes with reports only.\n"
  if $opt{'reports-only'} && ($opt{'full-mode'} || $opt{'incremental-mode'});

# read configuration
require './config'; ## no critic (Modules::RequireBarewordIncludes)
use vars qw($LINTIAN_ROOT $LINTIAN_LAB $LINTIAN_ARCHIVEDIR $LINTIAN_DIST
  $LINTIAN_ARCH @EXTRA_LINTIAN_OPTIONS
  $LOG_DIR
  $HTML_DIR $HTML_TMP_DIR
  $LINTIAN_AREA $HARNESS_STATE_DIR

  $USE_PERMANENT_LAB
  $LINTIAN_SCRATCH_SPACE
);

# delete LINTIAN_{CFG,ROOT,LAB} in case they are set.
delete($ENV{'LINTIAN_CFG'});
delete($ENV{'LINTIAN_ROOT'});
delete($ENV{'LINTIAN_LAB'});
$ENV{'TMPDIR'} = $LINTIAN_SCRATCH_SPACE
  if defined($LINTIAN_SCRATCH_SPACE);

my $html_reports_cmd = "$LINTIAN_ROOT/reporting/html_reports";
my $dplint_cmd = "$LINTIAN_ROOT/frontend/dplint";

my ($log_file, $list_file, $lintian_log, $lintian_perf_log,$html_reports_log,
    $sync_state_log)
  = map {"$LOG_DIR/$_" }
  qw(harness.log changed-packages.list lintian.log lintian-perf.log html_reports.log sync_state.log);
my $old_lintian_log = $lintian_log . '.old';
my @lintian_cmd = (
    "$LINTIAN_ROOT/frontend/lintian",
    @EXTRA_LINTIAN_OPTIONS,
    qw(--no-cfg -I -E --pedantic -v --show-overrides),
    qw(--exp-output=format=fullewi --packages-from-file -),
    qw(--perf-debug --perf-output),
    "+$lintian_perf_log",
);
my $STATE_DIR = $HARNESS_STATE_DIR;
my $START_TIME = time();

# import perl libraries
unshift @INC, "$LINTIAN_ROOT/lib";
require Lintian::Command;
import Lintian::Command qw(spawn safe_qx);
require Lintian::Lab;
require Lintian::Lab::Manifest;
require Lintian::Processable;
require Lintian::Relation::Version;
import Lintian::Relation::Version qw(versions_comparator);
require Lintian::Util;
import Lintian::Util qw(open_gz slurp_entire_file strip visit_dpkg_paragraph
  load_state_cache find_backlog save_state_cache);

my $LINTIAN_VERSION
  = safe_qx("$LINTIAN_ROOT/frontend/lintian",'--print-version');
chomp($LINTIAN_VERSION);

# turn file buffering off
STDOUT->autoflush;

unless ($opt{'dry-run'}) {
    # rotate log files
    my %opt = ('out' => '/dev/null',);
    my @rotate_logs
      = ($log_file, $html_reports_log, $lintian_perf_log, $sync_state_log);
    spawn(\%opt, ['savelog', @rotate_logs])
      or die "Cannot rotate log files.\n";

    # create new log file
    open($LOG_FD, '>', $log_file)
      or die "cannot open log file $log_file for writing: $!";
} else {
    $opt{'to-stdout'} = 0;
    open($LOG_FD, '>&', \*STDOUT)
      or die "Cannot open log file <stdout> for writing: $!";
    Log('Running in dry-run mode');
}
# From here on we can use Log() and Die().

if (not defined($STATE_DIR)) {
    Die(q{Missing required config option: $HARNESS_STATE_DIR});
} else {
    if (not $opt{'dry-run'} and $opt{'clean-mode'}) {
        Log("Purging old state-cache/dir");
        system('rm', '-rf', $STATE_DIR) == 0
          or Die("error removing $STATE_DIR");
    }

    if (not -d $STATE_DIR) {
        system('mkdir', '-p', $STATE_DIR) == 0
          or Die("mkdir -p $STATE_DIR failed");
        Log("Created cache dir: $STATE_DIR");
    }
}

if (not $opt{'dry-run'}) {

    if ($USE_PERMANENT_LAB) {
        my $LAB = Lintian::Lab->new($LINTIAN_LAB);
        # purge the old packages
        $LAB->remove if $opt{'clean-mode'};

        $LAB->create({ 'mode' => 02775}) unless $LAB->exists;
    } elsif ($LINTIAN_LAB) {
        my $LAB = Lintian::Lab->new($LINTIAN_LAB);
        Log("Removing old permanent lab at $LINTIAN_LAB");
        $LAB->remove if $LAB->exists;
    }
}

if ($USE_PERMANENT_LAB) {
    push(@lintian_cmd, '--lab', $LINTIAN_LAB);
}

if (!$opt{'reports-only'} && !$opt{'full-mode'} && !$opt{'incremental-mode'}) {
    # Nothing explicitly chosen, default to -i if the log is present,
    # otherwise -f.
    if (-f $lintian_log) {
        $opt{'incremental-mode'} = 1;
    } else {
        $opt{'full-mode'} = 1;
    }
}

if (not $opt{'reports-only'}) {
    my ($state, @worklist);
    my $scs = $opt{'schedule-chunk-size'};
    my @sync_state_args = (
        '--state-dir', $STATE_DIR,
        '--mirror-path', $LINTIAN_ARCHIVEDIR,
        '--distributions', $LINTIAN_DIST,
        '--mirror-areas', $LINTIAN_AREA,
        '--architectures', $LINTIAN_ARCH,
        '--desired-version', $LINTIAN_VERSION,
        '--debug',
    );

    if ($opt{'full-mode'}) {
        push(@sync_state_args, '--reschedule-all');
    }
    if ($opt{'dry-run'}) {
        push(@sync_state_args, '--dry-run');
    }

    Log('Updating harness state cache (reading mirror index files)');
    my %sync_state_opts = (
        'out' => $sync_state_log,
        'err' => '&1',
    );
    delete($sync_state_opts{'out'}) if $opt{'dry-run'};
    spawn(\%sync_state_opts,
        [$dplint_cmd, 'reporting-sync-state', @sync_state_args])
      or Log("warning: executing reporting-sync-state returned "
          . (($? >> 8) & 0xff));

    Log('Update complete, loading current state information');
    eval {$state = load_state_cache($STATE_DIR);};
    if ($@) {
        Die($@);
    }

    @worklist = find_backlog($LINTIAN_VERSION, $state);

    # Sanity check for incremental mode.
    die "Old Lintian log file $lintian_log not found!\n"
      if ($opt{'incremental-mode'} and not -f $lintian_log);

    # Always update the log if it exists, as we may have removed some
    # entries.
    if (-f $lintian_log) {
        my $filter = generate_log_filter($state, \@worklist);

        # update lintian.log
        Log('Updating lintian.log...');
        rewrite_lintian_log($lintian_log, $filter);
    }

    Log('');

    if (not @worklist) {
        Log('Skipping Lintian run - nothing to do...');
    } else {
        Log('Processing backlog...');
        if (@worklist > BACKLOG_PROCESSING_GROUP_LIMIT) {
            Log(
                "Truncating worklist to size ${\BACKLOG_PROCESSING_TIME_LIMIT}"
                  . ' from '
                  . (scalar(@worklist)));
            @worklist = splice(@worklist, 0, BACKLOG_PROCESSING_GROUP_LIMIT);
        }
    }

    process_worklist(\@worklist, $state, $lintian_log, $STATE_DIR, $scs);
}

# create html reports
Log('Creating HTML reports...');
Log("Executing $html_reports_cmd $lintian_log");
my %html_reports_opts = (
    'out' => $html_reports_log,
    'err' => '&1',
);
spawn(\%html_reports_opts, [$html_reports_cmd, $lintian_log])
  or
  Log("warning: executing $html_reports_cmd returned " . (($? >> 8) & 0xff));
Log('');

# rotate the statistics file updated by $html_reports_cmd
if (!$opt{'dry-run'} && -f "$HARNESS_STATE_DIR/statistics") {
    my $date = time2str('%Y%m%d', time());
    my $dest = "$LOG_DIR/stats/statistics-${date}";
    system('cp', "$HARNESS_STATE_DIR/statistics", $dest) == 0
      or Log('warning: could not rotate the statistics file');
}

# install new html directory
Log('Installing HTML reports...');
unless ($opt{'dry-run'}) {
    system('rm', '-rf', $HTML_DIR) == 0
      or Die("error removing $HTML_DIR");
    # a tiny bit of race right here
    rename($HTML_TMP_DIR,$HTML_DIR)
      or Die("error renaming $HTML_TMP_DIR into $HTML_DIR");
}
Log('');

# ready!!! :-)
Log('All done.');
exit 0;

# -------------------------------

sub Log {
    my ($msg) = @_;
    my $ts = strftime('[%FT%T]: ', localtime());
    print {$LOG_FD} $ts, $msg,"\n";
    print $ts, $msg, "\n" if $opt{'to-stdout'};
    return;
}

sub Die {
    Log("fatal error: $_[0]");
    exit 1;
}

sub process_worklist {
    my ($worklist_ref, $state, $output_file, $state_dir,$schedule_chunk_size)
      = @_;
    my $round = 0;
    my $rounds = 1;
    my @worklist = @{$worklist_ref};
    my (@slice, $filter_set);

    if ($schedule_chunk_size > 0) {
        # compute the number of rounds needed.
        my $size_up = scalar @worklist + ($schedule_chunk_size - 1);
        $rounds = int($size_up / $schedule_chunk_size);
    }

    Log(
        sprintf(
            'Groups to process %d will take %d round(s) [round limit: %s]',
            scalar @worklist,
            $rounds,$schedule_chunk_size > 0 ? $schedule_chunk_size : 'none'
        ));

    Log('Command line used: ' . join(q{ }, @lintian_cmd));
    while (@worklist) {
        my $len = scalar @worklist;
        my (@work_splice, @completed, $signaled);
        my ($lintpipe, $lint_stdin, $status_fd, $lint_status_out);

        if (time() >= $START_TIME + BACKLOG_PROCESSING_TIME_LIMIT) {
            Log('No more time for processing backlogs');
            last;
        }

        $round++;
        # correct bounds to fit chunk size
        if ($schedule_chunk_size > 0 and $len > $schedule_chunk_size) {
            $len = $schedule_chunk_size;
        }

        @work_splice = splice(@worklist, 0, $len);

        Log("Running Lintian (round $round/$rounds) ...");
        if ($len == 1) {
            Log(' - Single group: ' . $work_splice[0]);
        } else {
            Log(    ' - Range: GROUP:'
                  . $work_splice[0]
                  . q{ ... GROUP:}
                  . $work_splice[-1]);
        }

        next if ($opt{'dry-run'});

        pipe($lint_stdin, $lintpipe) or Die("pipe failed: $!");
        pipe($status_fd, $lint_status_out) or Die("pipe failed: $!");
        my $pid = fork() // Die("fork failed: $!");
        if (not $pid) {
            # child => juggle some fds, close some pipes and exec lintian
            my $status_fileno = fileno($lint_status_out);
            # Perl is helpful and sets close-on-exec by default for fd > $^F.
            # - except, in this case, that is *not* what we want.
            my $flags = fcntl($lint_status_out, F_GETFD, 0)
              or die("fcntl F_GETFD: $!");
            fcntl($lint_status_out, F_SETFD, $flags & ~FD_CLOEXEC)
              or die("fcntl F_SETFD: $!");
            open(STDIN, '<&', $lint_stdin);
            open(STDOUT, '>>', $lintian_log)
              or die("re-open STDOUT failed: $!");
            open(STDERR, '>&', *STDOUT)
              or die("re-open STDERR failed: $!");
            close($lintpipe)
              or die("closing \"lintpipe\" pipe (not for us): $!");
            close($status_fd)
              or die("closing \"status_fd\" pipe (not for us): $!");
            push(@lintian_cmd, '--status-log', '&' . ${status_fileno});
            exec(@lintian_cmd)
              or die("exec @lintian_cmd failed: $!");
        }
        # Close the end points only the child needs
        close($lint_stdin)
          or Die("Cannot close \"lint_stdin\" pipe (not for us): $!");
        close($lint_status_out)
          or Die("Cannot close \"lint_status_out\" pipe (not for us): $!");

        my $groups = $state->{'groups'};
        # Submit the tasks to Lintian
        foreach my $group_id (@work_splice) {
            my $members;
            if (not exists($groups->{$group_id})) {
                # Sanity check (can in theory happen if an external process
                # modifies the state cache and we have reloaded it)
                Log(
                    "Group ${group_id} disappeared before we could schedule it"
                );
                next;
            }
            $members = $groups->{$group_id}{'members'};
            for my $member_id (sort(keys(%{${members}}))) {
                my $path = $members->{$member_id}{'path'};
                print {$lintpipe} "$path\n";
            }
            #print {$lintpipe} "!query: GROUP:$group_id\n";
        }
        close($lintpipe) or Die("Closing pipe failed: $!");

        # Listen to status updates from lintian
        while (my $line = <$status_fd>) {
            chomp($line);
            if ($line =~ s/^complete ([^ ]+) \(([^\)]+)\)$//) {
                push(@completed, $1);
                Log("  [lintian] processed $1 successfully (time: $2)");
            } elsif ($line =~ s/^error ([^ ]+) \(([^\)]+)\)$//) {
                Log("  [lintian] error processing $1 (time: $2)");
            }
        }
        close($status_fd);

        # Wait for lintian to terminate
        waitpid($pid, 0) == $pid or Die("waitpid($pid, 0) failed: $!");
        if ($?) {
            # exit 1 (policy violations) happens all the time (sadly)
            # exit 2 (broken packages) also happens all the time...
            my $res = ($? >> 8) & 0xff;
            my $sig = $? & 0xff;
            if ($res != 1 and $res != 0) {
                Log("warning: executing lintian returned $res");
            } elsif ($sig) {
                Log("Lintian terminated by signal: $sig");
                # If someone is sending us signals (e.g. SIGINT/Ctrl-C)
                # don't start the next round.
                Log(' - skipping the rest of the worklist');
                @worklist = ();
                $signaled = 1;
            }
        } else {
            Log('Lintian finished successfully');
        }
        Log('Updating harness state cache');
        # Reload the state cache, just in case it was modified by an external
        # process during the lintian run.
        eval {$state = load_state_cache($STATE_DIR);};
        if ($@) {
            Die($@);
        }
        for my $group_id (@completed) {
            my $group_data;
            # In theory, they can disappear - in practise, that requires
            # an external call to (e.g.) dplint reporting-sync-state.
            next if not exists($state->{'groups'}{$group_id});
            $group_data = $state->{'groups'}{$group_id};
            $group_data->{'last-processed-by'} = $LINTIAN_VERSION;
            delete($group_data->{'out-of-date'});
        }
        save_state_cache($STATE_DIR, $state);
        return if $signaled;
    }
    return $state;
}

sub rewrite_lintian_log {
    my ($lintian_log, $keep_filter) = @_;
    return if ($opt{'dry-run'});

    rename($lintian_log, $old_lintian_log)
      or Die("cannot rename lintian.log to $old_lintian_log: $!");
    open(my $nfd, '>', $lintian_log)
      or Die("cannot open lintian.log $lintian_log for writing: $!");
    open(my $ofd, '<', $old_lintian_log)
      or Die("cannot open old lintian.log $old_lintian_log for reading: $!");
    my $copy_mode = 0;
    while (<$ofd>) {
        if (
            m/^N: [ ] Processing [ ] (binary|udeb|source) [ ]
                   package [ ] (\S+) [ ] \(version [ ] (\S+), [ ]
                   arch [ ] (\S+)\)[ ]\.\.\./oxsm
          ) {
            my ($type, $pkg, $ver, $arch) = ($1,$2, $3, $4);
            my $k = "$type:$pkg/$ver";
            $k .= "/$arch" if $type ne 'source';
            $copy_mode = 0;
            $copy_mode = 1 if exists($keep_filter->{$k});
        }
        if ($copy_mode) {
            print {$nfd} $_;
        }
    }
    print {$nfd} "N: ---end-of-old-lintian-log-file---\n";
    close($nfd) or Die("Close $lintian_log: $!");
    close($ofd); # Ignore (read-only handle)
    return 1;
}

sub generate_log_filter {
    my ($state, $worklist_ref) = @_;
    my %filter;
    my $group_map = $state->{'groups'};
    for my $group_id (keys(%{${group_map}})) {
        my $members = $group_map->{$group_id}{'members'};
        for my $member_id (keys(%{$members})) {
            $filter{$member_id} = 1;
        }
    }
    return \%filter;
}

# Local Variables:
# indent-tabs-mode: nil
# cperl-indent-level: 4
# End:
# vim: syntax=perl sw=4 sts=4 sr et
