#!/usr/bin/perl

# Copyright © 1998 Richard Braakman
# Copyright © 2008 Frank Lichtenheld
# Copyright © 2008 Russ Allbery
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

# The harness for Lintian's new test suite.  Normally run through the runtests
# or check-tag targets in debian/rules.  For detailed information on the test
# suite layout and naming conventions, see t/tests/README.

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long qw(GetOptions);
use Text::Template;

sub usage {
    print <<END;
Usage: $0 [-dkv] testset-directory testing-directory [test]
       $0 [-dkv] [-t tag] testset-directory testing-directory

The -k option means do not stop after one failed test, but try
them all and report all errors.

The -v option will also display those tests that have a description, but are
not tested in any testset-package.

The -d option will display debugging information.

The -t tag option will only run tests that test for or against that tag.

The optional 3rd parameter causes runtests to only run that particular test.
END
    exit 2;
}

# The build output is directed to build.pkgname in the testing-directory.

# Exit codes:
# 0 - success
# 1 - one or more tests failed
# 2 - an error prevented proper running of the tests

my $debug = 0;
my $run_all_tests = 0;
my $tag;
my $verbose = 0;

# --- Parse options and arguments
Getopt::Long::Configure('bundling');
GetOptions('d|debug'      => \$debug,
	   'k|keep-going' => \$run_all_tests,
	   't|tag=s'      => \$tag,
	   'v|verbose'    => \$verbose) or usage;
if ($#ARGV < 1 || $#ARGV > 2) {
    usage;
}
my ($testset, $rundir, $singletest) = @ARGV;
if ($tag and $singletest) {
    usage;
}

# --- Set and unset environment variables that lintian is sensitive to
BEGIN {
    my $LINTIAN_ROOT = $ENV{'LINTIAN_ROOT'};
    if (not $LINTIAN_ROOT) {
	use Cwd ();
	$ENV{'LINTIAN_ROOT'} = $LINTIAN_ROOT = Cwd::cwd();
    }
    delete $ENV{'LINTIAN_CFG'};
    delete $ENV{'LINTIAN_LAB'};
    delete $ENV{'LINTIAN_DIST'};
    delete $ENV{'LINTIAN_UNPACK_LEVEL'};
    $ENV{'LC_COLLATE'} = 'C';

    # Set standard umask because many of the test packages rely on this
    # when creating files from the debian/rules script.
    umask(022);
}

my $LINTIAN_ROOT = $ENV{'LINTIAN_ROOT'};

use lib "$ENV{'LINTIAN_ROOT'}/lib";
use Util;
use Tags;

# --- Set the ways to call lintian and dpkg-buildpackage
my $lintian_options = '-I -E';
my $dpkg_buildpackage_options = '-rfakeroot -us -uc -d -iNEVER_MATCH_ANYTHING'
    . ' -INEVER_MATCH_ANYTHING';
my $lintian_path = $LINTIAN_ROOT . "/frontend/lintian";

# --- Display output immediately
$| = 1;

# --- Let's play.

-d $rundir
    or fail("test directory $rundir does not exist\n");

# in temporary labs
my @tests;
if ($singletest) {
    @tests = map { s/\.desc$//; $_ } ( $singletest );
} elsif ($tag) {
    @tests = find_tests_for_tag($tag);
} else {
    -d $testset
	or fail("cannot find $testset: $!\n");

    @tests = map { s#^\Q$testset/tests/\E## ;s/\.desc$//; $_ } sort(<$testset/tests/*.desc>);
}

print "Found the following tests: @tests\n" if $debug;
my $tests_run = 0;
for (@tests) {
    my $testdesc = "$testset/tests/$_.desc";
    next unless -f $testdesc;

    print "process $testdesc...\n" if $debug;
    my $testdata = (read_dpkg_control($testdesc))[0];

    check_test_is_sane($testset, $testdata);
    print "Running test $testdata->{testname} $testdata->{version}... ";

    my $pkg = $testdata->{srcpkg};
    my $pkgdir = "$pkg-$testdata->{version}";
    my $origdir = "$testset/tests/$testdata->{testname}";
    my $targetdir = "$rundir/$pkgdir";
    my $tmpldir = "$testset/templates";

    my $is_native = ($testdata->{type} eq 'native');
    my $orig_version = $testdata->{version};

    # Strip the Debian revision off of the name of the target directory and
    # the *.orig.tar.gz file if the package is non-native.  Otherwise, it
    # confuses dpkg-source, which then fails to find the upstream tarball and
    # builds a native package.
    unless ($is_native) {
	for ($orig_version, $pkgdir, $targetdir) {
	    s/-[^-]+$//;
	}
    }

    print "Cleaning up and repopulating $targetdir...\n" if $debug;
    runsystem_ok("rm", "-rf", $targetdir);
    if ($is_native) {
	runsystem("cp", "-rp", "$tmpldir/skel", $targetdir);
	runsystem("rm", "-f", "$targetdir/debian/changelog");
	runsystem("rsync", "-rp", "$origdir/debian/", "$targetdir/")
	    if -d "$origdir/debian/";
    } else {
	runsystem("cp", "-rp", "$tmpldir/skel.upstream", $targetdir);
	runsystem("rm", "-f", "$targetdir/.dummy");
	runsystem("rsync", "-rp", "$origdir/upstream/", "$targetdir/");
	runsystem("cd $rundir && ".
		  "tar czf ${pkg}_${orig_version}.orig.tar.gz $pkgdir");
	runsystem("rsync", "-rp", "--exclude=debian/changelog",
		  "$tmpldir/skel/", "$targetdir/");
	runsystem("rsync", "-rp", "$origdir/debian/", "$targetdir/")
	    if -d "$origdir/debian/";
    }

    unless (-e "$targetdir/debian/changelog") {
	fill_in_tmpl("$targetdir/debian/changelog", $testdata);
    }
    unless (-e "$targetdir/debian/control") {
	fill_in_tmpl("$targetdir/debian/control", $testdata);
    }
    unless ($is_native || -e "$targetdir/debian/watch") {
	runsystem("echo >$targetdir/debian/watch");
    }
    if (-x "$origdir/pre_build") {
	print "running pre_build hook... " if $verbose;
	runsystem("$origdir/pre_build", $targetdir);
    }

    print "building... ";
    runsystem("cd $rundir/$pkgdir && dpkg-buildpackage $dpkg_buildpackage_options >../build.$pkg 2>&1");

     print "testing... ";
     runsystem_ok("$lintian_path $lintian_options $rundir/$pkg\_$testdata->{version}*.changes".
		  " 2>&1 | sort > $rundir/tags.$pkg");

    # Run a sed-script if it exists, for tests that have slightly variable
    # output
    runsystem_ok("sed -i -f $origdir/post_test $rundir/tags.$pkg")
	if -e "$origdir/post_test";

    my $testok = runsystem_ok("cmp", "-s", "$rundir/tags.$pkg", "$origdir/tags");
    $tests_run++;
    if ($testok) {
	print "ok.\n";
    } else {
	print "FAILED:\n";
	runsystem_ok("diff", "-u", "$origdir/tags", "$rundir/tags.$pkg");
	exit 1 unless $run_all_tests;
	next;
    }

    # Check the output for invalid lines.  Also verify that all Test-For tags
    # are seen and all Test-Against tags are not.
    my %test_for = map { $_ => 1 } split(' ', $testdata->{'test-for'});
    my %test_against = map { $_ => 1 } split(' ', $testdata->{'test-against'});
    open TAGS, "$rundir/tags.$pkg" or fail("Cannot open $rundir/tags.$pkg");
    while (<TAGS>) {
	next if m/^N: /;
	if (not /^(.): (\S+)(?: (?:source|udeb))?: (\S+)/) {
	    print "E: Invalid line:\n$_";
	    next;
	}
	my $tag = $3;
	if ($test_against{$tag}) {
	    print "E: Tag $tag seen but listed in Test-Against\n";
	}
	delete $test_for{$tag};
    }
    close TAGS;
    if (%test_for) {
	for my $tag (sort keys %test_for) {
	    print "E: Tag $tag listed in Test-For but not found\n";
	}
    }
}

if (!$tests_run) {
    if ($singletest) {
	print "W: No tests run, did you specify a valid test name?\n";
    } elsif ($tag) {
	print "I: No tests found for that tag.\n";
    } else {
	print "E: No tests run, did you specify a valid testset directory?\n";
    }
}

# --------------
sub runsystem {
    print "runsystem(@_)\n" if $debug;
    system(@_) == 0
	or fail("failed: @_\n");
}

sub runsystem_ok {
    print "runsystem_ok(@_)\n" if $debug;
    my $errcode = system(@_);
    $errcode == 0 or $errcode == (1 << 8)
	or fail("failed: @_\n");
    return $errcode == 0;
}

sub fill_in_tmpl {
    my ($file, $data) = @_;
    my $tmpl = "$file.in";

    my $template = Text::Template->new(TYPE => 'FILE',  SOURCE => $tmpl);
    open my $out, '>', $file
	or fail("cannot open $file: $!");

    unless ($template->fill_in(OUTPUT => $out, HASH => $data)) {
	fail("cannout create $file");
    }
    close $out;
}

sub check_test_is_sane {
    my ($dir, $data) = @_;

    if ($debug) {
	print "check_test_is_sane <= ".Dumper($data);
    }

    unless ($data->{testname} && $data->{version}) {
	fail("Name or Version missing");
    }

    $data->{srcpkg} ||= $data->{testname};
    $data->{type} ||= 'native';
    $data->{date} ||= `date -R`; chomp $data->{date};
    $data->{description} ||= 'No Description Available';
    $data->{author} ||= 'Debian Lintian Maintainers <lintian-maint@debian.org>';
    $data->{architecture} ||= 'all';
    $data->{section} ||= 'devel';

    $data->{'test-for'} ||= '';
    $data->{'test-against'} ||= '';

    if ($debug) {
	print "check_test_is_sane => ".Dumper($data);
    }
}

# Find all tests that check a particular tag, either for its presence or
# absence.  Returns a list of names of the *.desc files, without the *.desc at
# the end.
sub find_tests_for_tag {
    my ($tag) = @_;
    my @tests;
    for my $test (<$testset/tests/*.desc>) {
	my ($testname) = ($test =~ m,.*/([^/]+)\.desc$,);
	my ($data) = read_dpkg_control($test);
	if ($data->{'test-for'}) {
	    my %for = map { $_ => 1 } split(' ', $data->{'test-for'});
	    if ($for{$tag}) {
		push (@tests, $testname);
		next;
	    }
	}
	if ($data->{'test-against'}) {
	    my %against = map { $_ => 1 } split(' ', $data->{'test-against'});
	    if ($against{$tag}) {
		push (@tests, $testname);
	    }
	}
    }
    return @tests;
}

# Local Variables:
# indent-tabs-mode: t
# cperl-indent-level: 4
# End:
# vim: ts=8 sw=4
