# control-file -- lintian check script -*- perl -*-
#
# Copyright (C) 2004 Marc Brockschmidt
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

package Lintian::control_file;
use strict;
use Util;
use Tags;

sub run {

my $pkg = shift;
my $type = shift;

if (-l "debfiles/control") {
    tag "debian-control-file-is-a-symlink", "";
}

# check that control is UTF-8 encoded
my $line = file_is_encoded_in_non_utf8("debfiles/control", $type, $pkg);
if ($line) {
    tag "debian-control-file-uses-obsolete-national-encoding", "at line $line"
}

# Check that each field is only used once:
my $seen_fields = {};
open (CONTROL, "debfiles/control") or fail "Couldn't read debfiles/control: $!";
while (<CONTROL>) {
	s/\s*\n$//;

	#Reset seen_fields if we enter a new section:
	$seen_fields = {} if /^$/;

	#line with field:
	if (/^(\S+):/) {
		my $field = lc ($1);
		if ($seen_fields->{$field}) {
			tag "debian-control-with-duplicate-fields", "$field: $$seen_fields{$field}, $.";
		}
		$seen_fields->{$field} = $.;
	}
}
close CONTROL;

my ($header, @binary_controls) = read_dpkg_control("debfiles/control");

for my $binary_control (@binary_controls) {
	tag "build-info-in-binary-control-file-section", "Package ".$binary_control->{"package"}
	    if ($binary_control->{"build-depends"} || $binary_control->{"build-depends-indep"} ||
	        $binary_control->{"build-conflicts"} || $binary_control->{"build-conflicts-indep"});
}

# Check that every package is in the same archive category.  The source
# package may or may not have a section specified; if it doesn't, derive the
# expected archive category from the first binary package by leaving $category
# undefined until parsing the first binary section.  Missing sections will be
# caught by other checks.
my $category;
if ($header->{'section'}) {
	if ($header->{'section'} =~ m%^([^/]+)/%) {
		$category = $1;
	} else {
		$category = '';
	}
} else {
	tag "no-section-field-for-source", "";
}
for my $binary_control (@binary_controls) {
	next unless $binary_control->{'section'};
	if (!defined ($category)) {
		if ($binary_control->{'section'} =~ m%^([^/]+)/%) {
			$category = $1;
		} else {
			$category = '';
		}
		next;
	}
	tag "section-category-mismatch", "Package " . $binary_control->{'package'}
		if ($category && $binary_control->{'section'} !~ m%^$category/%);
	tag "section-category-mismatch", "Package " . $binary_control->{'package'}
		if (!$category && $binary_control->{'section'} =~ m%^[^/]+/%);
}

}

1;

# vim: syntax=perl sw=4 ts=4 noet shiftround
