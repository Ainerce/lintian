#!/usr/bin/perl -W
# fields -- lintian check script (rewrite)
#
# Copyright (C) 2004 Marc Brockschmidt
#
# Parts of the code were taken from the old check script, which
# was Copyright (C) 1998 Richard Braakman (also licensed under the
# GPL 2 or higher)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
# MA 02111-1307, USA.

use strict;
use lib "$ENV{'LINTIAN_ROOT'}/checks/";
use common_data;

($#ARGV == 1) or fail("syntax: fields <pkg> <type>");
my $pkg = shift;
my $type = shift;
my $version;

$/ = undef; #Read everything in one go

unless (-d "fields") {
	fail("directory in lintian laboratory for $type package $pkg missing: fields");
}

#---- Package

if ($type eq "binary"){
	if (not open (FH, "fields/package")) {
		print "E: $pkg $type: no-package-name\n";
	} else {
		my $name = <FH>;
		close FH;

		unfold("package", \$name);
	
		print "E: $pkg $type: bad-package-name\n" unless $name =~ /^[A-Z0-9][-+\.A-Z0-9]+$/i;
		print "E: $pkg $type: package-not-lowercase\n" if ($name =~ /[A-Z]/)
	}
}

#---- Version

if (not open (FH, "fields/version")) {
	print "E: $pkg $type: no-version-field\n";
} else {
	$version = <FH>;
	close FH;

	unfold("version", \$version);

	if (my ($epoch, $upstream, $debian) = _valid_version($version)) {
		if ($upstream !~ /^\d/i) {
			print "W: $pkg $type: upstream-version-not-numeric\n";
		}
	} else {
		print "E: $pkg $type: bad-version-number\n";
	}
}

#---- Architecture

if (not open (FH, "fields/architecture")) {
	print "E: $pkg $type: no-architecture-field\n";
} else {
	my $archs = <FH>;
	close FH;

	unfold("architecture", \$archs);

	my @archs = split / /, $archs;

	if (@archs > 1 && grep { $_ eq "any" || $_ eq "all" } @archs) {
		print "E: $pkg $type: magic-arch-in-arch-list\n";
	}

	for my $arch (@archs) {
		unless ($known_archs{$arch}) {
			print "E: $pkg $type: unknown-architecture\n";
		}
	}

	if ($type eq "binary") {
		print "E: $pkg $type: too-many-architectures\n" if (@archs > 1);
		print "E: $pkg $type: arch-any-in-binary-pkg\n" if (grep { $_ eq "any" } @archs);
	}
}

#---- Subarchitecture (udeb)

if (open(FH, "fields/subarchitecture")) {
	my $subarch = <FH>;
	close(FH);

	unfold("subarchitecture", \$subarch);
}

#---- Maintainer
#---- Uploaders

for my $f (qw(maintainer uploaders)) {
	if (not open (FH, "fields/$f")) {
		print "E: $pkg $type: no-maintainer-field\n" if $f eq "maintainer";
	} else {
		my $maintainer = <FH>;
		close FH;

		unfold($f, \$maintainer);

		$maintainer =~ s/^\s*(.+?)\s*$/$1/; #Remove leading and trailing whitespace

		if ($f eq "uploaders") {
			check_maint($_, "uploader") for (split /\s*,\s*/, $maintainer);
		} else {
			check_maint($maintainer, $f);
		}
	}
}

#---- Source

if ($type eq "source") {
	if (not open (FH, "fields/source")) {
		print "E: $pkg $type: no-source-field\n";
	} else {
		my $source = <FH>;
		close FH;
	
		unfold("source", \$source);
	
		if ($type eq 'source') {
			if ($source ne $pkg) {
				print "E: $pkg $type: source-field-does-not-match-pkg-name $_\n";
			}
		} else {
			if ($source !~ /[A-Z0-9][-+\.A-Z0-9]+                      #Package name
			                \s*
			                (?:\((?:\d+:)?(?:[-\.+:A-Z0-9]+?)(?:-[\.+A-Z0-9]+)?\))?\s*$/ix) { #Version
				print "E: $pkg $type: source-field-malformed $source\n";
			}
		}	
	}
}

#---- Essential

if (open (FH, "fields/essential")) {
	my $essential = <FH>;
	close FH;

	unfold("essential", \$essential);

	print "E: $pkg $type: essential-in-source-package\n" if ($type eq "source");
	print "E: $pkg $type: essential-no-not-needed\n" if ($essential eq "no");
	print "E: $pkg $type: unknown-essential-value\n" if ($essential ne "no" and $essential ne "yes");
	print "W: $pkg $type: new-essential-package\n" if ($essential eq "yes" and ! $known_essential{$pkg});
}

#---- Section

if (not open (FH, "fields/section")) {
	print "W: $pkg $type: no-section-field\n" if $type eq "binary";
} else {
	my $section = <FH>;
	close FH;

	unfold("section", \$section);

	my @parts = split /\//, $section, 2;

	if ($parts[0] =~ /non-US/i) {
		print "I: $pkg $type: non-us-spelling\n" if ($parts[0] ne "non-US");
		if ($parts[1] and not $known_non_us_parts{$parts[1]}) {
			print "W: $pkg $type: unknown-section $section\n";
		}
	} elsif (scalar @parts > 1) {
		print "W: $pkg $type: unknown-section $section\n" unless $known_archive_parts{$parts[0]};
		print "W: $pkg $type: unknown-section $section\n" unless $known_sections{$parts[1]};
	} else {
		print "W: $pkg $type: unknown-section $section\n" unless $known_sections{$parts[0]};
	}
}

#---- Priority

if (not open (FH, "fields/priority")) {
	print "W: $pkg $type: no-priority-field\n" if $type eq "binary";
} else {
	my $priority = <FH>;
	close FH;

	unfold("priority", \$priority);

	print "E: $pkg $type: unknown-priority $priority\n" if (! $known_prios{$priority});
}

#---- Standards-Version
# handled in checks/standards-version

#---- Description
# handled in checks/description

#---- Installer-Menu-Item (udeb)

if (open(FH, "fields/installer-menu-item")) {
	my $menu_item = <FH>;
	close(FH);

	unfold('installer-menu-item', \$menu_item);

	$menu_item =~ /^\d+$/ or print "E: $pkg $type: bad-menu-item $menu_item\n";
}


#---- Package relations (binary package)

if (($type eq "binary") || ($type eq 'udeb')) {
	my %deps;
	for my $field (qw(depends pre-depends recommends suggests conflicts provides replaces)) {
		if (open(FH, "fields/$field")) {
			#Get data and clean it
			my $data = <FH>;
			unfold($field, \$data);
			$data =~ s/^\s*(.+?)\s*$/$1/;

			my (@seen_libstdcs, @seen_tcls, @seen_tclxs, @seen_tks, @seen_tkxs, @seen_libpngs);

			my $is_dep_field = sub { grep { $_ eq $_[0] } qw(depends pre-depends recommends suggests) };

			print "E: $pkg $type: alternates-not-allowed $field\n"
			    if ($data =~ /\|/ && ! &$is_dep_field($field));

			for my $dep (split /\s*,\s*/, $data) {
				my @alternatives;
				push @alternatives, [_split_dep($_), $_] for (split /\s*\|\s*/, $dep);

				push @seen_libstdcs, $alternatives[0]->[0] if defined $known_libstdcs{$alternatives[0]->[0]};
				push @seen_tcls, $alternatives[0]->[0] if defined $known_tcls{$alternatives[0]->[0]};
				push @seen_tclxs, $alternatives[0]->[0] if defined $known_tclxs{$alternatives[0]->[0]};
				push @seen_tks, $alternatives[0]->[0] if defined $known_tks{$alternatives[0]->[0]};
				push @seen_tkxs, $alternatives[0]->[0] if defined $known_tkxs{$alternatives[0]->[0]};
				push @seen_libpngs, $alternatives[0]->[0] if defined $known_libpngs{$alternatives[0]->[0]};

				print "W: $pkg $type: virtual-package-depends-without-real-package-depends $field: $alternatives[0]->[0]\n"
					if ($known_virtual_packages{$alternatives[0]->[0]} && &$is_dep_field($field));

				for my $part_d (@alternatives) {
					my ($d_pkg, $d_version, $d_arch, $rest, $part_d_orig) = @$part_d;

					#Save the type of relationship (<<, <=, ...) and the field name:
					if (&$is_dep_field($field) && scalar @alternatives == 1) {
						$deps{$d_pkg} = [] if ! $deps{$d_pkg};
						push @{$deps{$d_pkg}}, [$field, $d_version];
					}

					print "E: $pkg $type: versioned-provides $part_d_orig\n"
					    if ($field eq "provides" && $d_version->[0]);

					print "W: $pkg $type: obsolete-relation-form $field: $part_d_orig\n"
					    if ($d_version && grep { $d_version->[0] eq $_ } ("<", ">"));

					print "E: $pkg $type: bad-version-in-relation $field: $part_d_orig\n"
					    if ($d_version->[0] && ! (_valid_version($d_version->[1]))[1]);
					
					print "W: $pkg $type: package-relation-with-self $field: $part_d_orig\n"
					    if ($pkg eq $d_pkg) && ($field ne 'conflicts');

					print "E: $pkg $type: bad-relation $field: $part_d_orig\n"
					    if $rest;

					print "E: $pkg $type: depends-on-obsolete-package $field: $part_d_orig\n"
					    if ($known_obsolete_packages{$d_pkg} && &$is_dep_field($field));

					print "E: $pkg $type: depends-on-essential-package-without-using-version $field: $part_d_orig\n"
					    if ($d_pkg ne "coreutils" && $known_essential{$d_pkg} && ! $d_version->[0] && &$is_dep_field($field));

					print "E: $pkg $type: package-depends-on-an-x-font-package $field: $part_d_orig\n"
					    if ($field =~ /^(pre-)?depends$/ && $d_pkg =~ /^xfont.*/);

					print "E: $pkg $type: needlessly-depends-on-awk $field\n"
					    if ($d_pkg eq "awk" && ! $d_version->[0] && &$is_dep_field($field));

					print "E: $pkg $type: depends-on-libdb1-compat $field\n"
					    if ($d_pkg eq "libdb1-compat" && $pkg !~ /^libc(6|6.1|0.3)/ && $field =~ /^(pre-)depends$/);

					print "W: $pkg $type: doc-package-depends-on-main-package $field\n"
					    if ("$d_pkg-doc" eq $pkg && $field =~ /^(pre-)depends$/);
				}
			}
			print "E: $pkg $type: package-depends-on-multiple-libstdc-versions ", join (" ", @seen_libstdcs), "\n"
			    if (scalar @seen_libstdcs > 1);
			print "E: $pkg $type: package-depends-on-multiple-tcl-versions ", join (" ", @seen_tcls), "\n"
			    if (scalar @seen_tcls > 1);
			print "E: $pkg $type: package-depends-on-multiple-tclx-versions ", join (" ", @seen_tclxs), "\n"
			    if (scalar @seen_tclxs > 1);
			print "E: $pkg $type: package-depends-on-multiple-tk-versions ", join (" ", @seen_tks), "\n"
			    if (scalar @seen_tks > 1);
			print "E: $pkg $type: package-depends-on-multiple-tkx-versions ", join (" ", @seen_tkxs), "\n"
			    if (scalar @seen_tkxs > 1);
			print "E: $pkg $type: package-depends-on-multiple-libpng-versions ", join (" ", @seen_libpngs), "\n"
			    if (scalar @seen_libpngs > 1);
		}
	}

	for my $d_pkg_name (keys %deps) {
		my $d_pkg = $deps{$d_pkg_name};
		if (scalar @$d_pkg > 1) {
			#Allow things like Depends: package1 (>= 1.3), package1 (<= 5.2)
			unless ((scalar @$d_pkg == 2) && 
			        (($d_pkg->[0]->[1]->[0] =~ />=|>>|>/ && $d_pkg->[1]->[1]->[0] =~ /<=|<<|</) or
			         ($d_pkg->[0]->[1]->[0] =~ /<=|<<|</ && $d_pkg->[1]->[1]->[0] =~ />=|>>|>/))) {
				print "E: $pkg $type: package-has-a-duplicate-relation ";
				my @relations;
			 	if ($d_pkg->[0][0] eq $d_pkg->[1][0]) {
					print "$d_pkg->[0][0]: ";
					for (@$d_pkg) {
						if ($_->[1][0]) {
							push @relations, "$d_pkg_name (".$_->[1][0]." ".$_->[1][1].")";
						} else {
							push @relations, "$d_pkg_name";
						}
					}
				} else {
					for (@$d_pkg) {
						if ($_->[1][0]) {
							push @relations, "$_->[0]: $d_pkg_name (".$_->[1][0]." ".$_->[1][1].")";
						} else {
							push @relations, "$_->[0]: $d_pkg_name";
						}
					}
				}
				print join( ", ", @relations ),"\n";
			}
		}
	}
}

#---- Package relations (source package)

if ($type eq "source") {
	
	#Get number of arch-indep packages:
	my $arch_indep_packages = 0;
	my $arch_dep_packages = 0;
	if (not open(CONTROL, "debfiles/control")) {
		fail("Can't open debfiles/control: $!");
	} else {
		local $/ = "\n"; #Read this linewise
		while (<CONTROL>) {	
			if (/^Architecture: all/) {			
				$arch_indep_packages++;
			} elsif (/^Architecture:/) {		
				$arch_dep_packages++;
			}
		}
	} 

	if (-e "fields/build-depends" && $arch_dep_packages == 0) {
		if (not open(BD, "fields/build-depends")) {
			fail("Can't open fields/build-depends");
		} else {
			my $build_depends = <BD>;
			close BD;

			my $uses_dh = 0;
			if (not open (RULES, "debfiles/rules")) {
				fail("cannot read debfiles/rules: $!");
			} else {
				my $target = "none";
				local $/ = "\n"; #Read this linewise				
				while (<RULES>) {
					$target = $1 if (/^(\S+):/);
					if (/^\s+dh_.+/ && grep ($_ eq $target, qw(clean binary-arch build-arch))) {
						$uses_dh = "yes";
						last
					}
				}
				close RULES;
			}
			unless ($build_depends =~ /^\s*debhelper(?:\s+\((.+?)\))?(?:\s+(\[.+?\]))?\s*$/ && $uses_dh){
				print "E: $pkg $type: build-depends-without-arch-dep\n"
			}
		}
	}

	print "E: $pkg $type: build-depends-indep-without-arch-indep\n"
		if (-e "fields/build-depends-indep" && $arch_indep_packages == 0);
	
	for my $field (qw(build-depends build-depends-indep build-conflicts build-conflicts-indep)) {
		if (open(FH, "fields/$field")) {
			#Get data and clean it
			my $data = <FH>;
			unfold($field, \$data);
			$data =~ s/^\s*(.+?)\s*$/$1/;

			for my $dep (split /\s*,\s*/, $data) {
				my @alternatives;
				push @alternatives, [_split_dep($_), $_] for (split /\s*\|\s*/, $dep);

				for my $part_d (@alternatives) {
					my ($d_pkg, $d_version, $d_arch, $rest, $part_d_orig) = @$part_d;

					for my $arch (@{$d_arch->[0]}) {
						print "E: $pkg $type: invalid-arch-string-in-source-relation $arch [$field: $part_d_orig]\n"
						    unless ($known_archs{$arch} || $arch eq "any" || $arch eq "all");
					}

					print "E: $pkg $type: depends-on-build-essential-package-without-using-version $d_pkg [$field: $part_d_orig]\n"
					    if ($known_build_essential{$d_pkg} && ! $d_version->[1]);

					print "E: $pkg $type: depends-on-essential-package-without-using-version $field: $part_d_orig\n"
					    if ($d_pkg ne "coreutils" && $known_essential{$d_pkg} && ! $d_version->[0]);

					print "E: $pkg $type: bad-relation $field: $part_d_orig\n"
					    if $rest;
				}
			}
		}
	}
}

#----- Origin

if (open(FH, "fields/origin")) {
	my $origin = <FH>;
	close(FH);

	unfold('origin', \$origin);

	print "W: $pkg $type: redundant-origin-field\n" if $origin =~ /^\s*debian\s*$/i;
}

#----- Field checks (without checking the value)

for my $field (glob("fields/*")) {
	$field =~ s!^fields/!!;

	print "E: $pkg $type: obsolete-field $field\n"
	    if $known_obsolete_fields{$field};

	print "N: $pkg $type: unknown-field-in-dsc $field\n"
	    if ($type eq "source" && ! $known_source_fields{$field} && ! $known_obsolete_fields{$field});

	print "N: $pkg $type: unknown-field-in-changes $field\n"
	    if ($type eq "binary" && ! $known_binary_fields{$field} && ! $known_obsolete_fields{$field});
}

exit 0;

# -----------------------------------

sub fail {
	if ($_[0]) {
		warn "internal error: $_[0]\n";
	} elsif ($!) {
		warn "internal error: $!\n";
	} else {
		warn "internal error.\n";
	}
	exit 1;
}

# splits "foo (>= 1.2.3) [!i386 ia64]" into
# ( "foo", [ ">=", "1.2.3" ], [ [ "i386", "ia64" ], 1 ], "" )
#                                                  ^^^   ^^
#                                 true, if ! was given   ||
#           rest (should always be "" for valid dependencies)
sub _split_dep {
	my $dep = shift;
	my ($pkg, $version, $darch) = ("", ["",""], [[],""]);

	$pkg = $1 if $dep =~ s/^\s*([^\s\[\(]+)\s*//;

	if (length $dep) {
		if ($dep =~ s/\s* \( \s* (<<|<=|<|=|>=|>>|>) \s* ([^(]+) \) \s*//x) {
			@$version = ($1, $2);
		}
		if ($dep && $dep =~ s/\s*\[([^\]]+)\]\s*//) {
			my $t = $1;
			$darch->[1] = 1 if ($t =~ s/!//g);
			$darch->[0] = [ split /\s+/, $t ];
		}
	}

	return ($pkg, $version, $darch, $dep);
}

sub _valid_version {
	my $ver = shift;

	if ($ver =~ m/^(\d+:)?([-\.+:A-Z0-9]+?)(-[\.+A-Z0-9]+)?$/i) {
		return ($1, $2, $3);
	} else {
		return undef;
	}
}

sub unfold {
	my $field = shift;
	my $line = shift;

	$$line =~ s/\n$//;

	if ($$line =~ s/\n//g) {
		print "E: $pkg $type: multiline-field $field\n";
	}
}

sub check_maint {
	my ($maintainer, $f) = @_;
	$maintainer =~ /^([^<\s]*(?:\s+[^<\s]+)*)?(\s*)(?:<(.+)>)?(.*)$/, 
	my ($name, $del, $mail, $crap) = ($1, $2, $3, $4);

	if (!$mail && $name =~ m/@/) { # name probably missing and address has no <>
		$mail = $name;
		$name = undef;
	}

	print "E: $pkg $type: $f-address-malformed $maintainer\n" if $crap;
	print "W: $pkg $type: $f-address-looks-weird $maintainer\n" if ! $del && $name && $mail;

	if (! $name) {
		print "E: $pkg $type: $f-name-missing $maintainer\n";
	} elsif ($name !~ /^\S+\s+\S+/) {
		print "W: $pkg $type: $f-not-full-name $name\n";
	}
			
	#This should be done with Email::Valid:
	if (!$mail) {
		print "E: $pkg $type: $f-address-missing $maintainer\n";
	} else {
		print "E: $pkg $type: $f-address-malformed $maintainer\n" 
		    unless ($mail =~ /^[^()<>@,;:\\"[\]]+@(\S+\.)+\S+/); #"

		print "E: $pkg $type: $f-address-is-on-localhost $maintainer\n"
		    if ($mail =~ /(?:localhost|\.localdomain|\.localnet)$/);

		print "E: $pkg $type: wrong-debian-qa-address-set-as-maintainer $maintainer\n"
		    if ($f eq "maintainer" && $mail eq 'debian-qa@lists.debian.org');
	}
}

# vim:set shiftwidth=4:
# vim:set tabstop=4:
# vim:set noet:
# vim:set shiftround:
