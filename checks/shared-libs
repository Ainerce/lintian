# shared-libs -- lintian check script

# Copyright (C) 1998 Christian Schwarz
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

package Lintian::shared_libs;
use strict;
use Tags;
use File::Basename;
use Util;

sub run {

my %ldso_dir = map { $_ => 1 }
    qw( lib
        usr/lib
        usr/lib/libg++-dbg
        usr/X11R6/lib/Xaw3d
        usr/local/lib
        usr/X11R6/lib
        usr/lib/libc5-compat
        lib/libc5-compat
      );

my $file;
my $must_call_ldconfig;
my $postrm = "control/postrm";
my $postinst = "control/postinst";
my $preinst = "control/preinst";
my $prerm = "control/prerm";
my $shlibs_control_file = "control/shlibs";
my %SONAME;
my %INTERP;
my %STACK;
my %objsomething;
my %sharedobject;
my %index_info;
my %link_info;
my @shlibs;
my @words;

# ---end-of-configuration-part---

my $pkg = shift;
my $type = shift;

# 1st step: get info about shared libraries installed by this package
open(IN,"objdump-info")
    or fail("cannot find objdump-info for $type package $pkg");
while (<IN>) {
    chop;

    #skip blank lines
    next if m/^\s*$/o;

    if (m/^-- (\S+)\s*$/o) {
	$file = $1; $file =~ s,^(\./)?,,;
    } elsif (m/^\s*SONAME\s+(\S+)/o) {
	$SONAME{$file} = $1;
    } elsif (m/^\s*TEXTREL\s/o) {
	tag "shlib-with-non-pic-code", "$file";
    } elsif (m/^\s*INTERP\s/) {
	$INTERP{$file} = 1;
    } elsif (m/^\s*STACK\s/) {
	$STACK{$file} = 0;
    } else {
        if (defined $STACK{$file} and $STACK{$file} eq 0) {
	    m/\sflags\s+(\S+)/o;
	    $STACK{$file} = $1;
	}
	else {
	    $objsomething{$file} = 1;
	}
    }
}
close(IN);

open IN, "file-info" or fail("cannot find file-info for $type package $pkg");
while (<IN>) {
    chomp;
    # with file names containing colons and spaces, we're fucked.
    m/^(?:\.\/)?(.+?):\s+(.*)$/o or fail("unrecognized file(1) output: $_");
    my ($file,$info) = ($1,$2);
    if ($info =~ m/^[^,]*\bELF\b/ && $info =~ m/shared object/) {
	$sharedobject{$file} = 1;
    }
}
close(IN);

# 2nd step: read package contents
my %files;
open(IN,"index") or fail("cannot open index file index: $!");
while (<IN>) {
    chop;
    @words = split(/\s+/o, $_, 6);
    my $perm = $words[0];
    my $cur_file = $words[5];
    $cur_file =~ s,^(\./),,;
    $cur_file =~ s/ link to .*//;

    if ($perm =~ m/^l/) {
	my $link;
	($cur_file, $link) = split(' -> ', $cur_file);
	$link_info{$cur_file} = $link;
    }
    $index_info{$cur_file} = 1;
    $files{$cur_file} = $perm;
}

for (keys %files) {
    my ($cur_file, $perm) = ($_, $files{$_});

    # shared library?
    if (exists $SONAME{$cur_file} or 
	($link_info{$cur_file} and exists $SONAME{abs_path(dirname($cur_file)."/".$link_info{$cur_file})})) {
	# yes!!
	
	my ($real_file, $real_perm);
	if ($SONAME{$cur_file}) {
	    $real_file = $cur_file;
	    $real_perm = $perm;
	} else {
	    $real_file = abs_path(dirname($cur_file)."/".$link_info{$cur_file});
	    $real_perm = $files{$real_file} || $perm;
	}

        # don't apply the permission checks to links
        # since this only results in doubled messages
        if ($cur_file eq $real_file) { 
            # executable?
            if ($real_perm =~ m/x/) {
                # yes.  But if the library has an INTERP section, it's designed
                # to do something useful when executed, so don't report an error.
                tag "shlib-with-executable-bit", $cur_file, sprintf("%04o",perm2oct($real_perm))
                    unless $INTERP{$real_file};
            } elsif ($real_perm ne '-rw-r--r--') {
                # bad permissions
                tag "shlib-with-bad-permissions", $cur_file, sprintf("%04o",perm2oct($real_perm));
            }
        }

	# installed in a directory controlled by the dynamic linker?
	if (exists $ldso_dir{dirname($cur_file)}) {
	    # yes! so postinst must call ldconfig
	    $must_call_ldconfig = $real_file;
	}

	# executable stack
	if (exists $objsomething{$cur_file}) {
	    if (not defined $STACK{$cur_file}) {
		tag "shlib-without-PT_GNU_STACK-section", $cur_file;
	    } elsif ($STACK{$cur_file} ne "rw-") {
		tag "shlib-with-executable-stack", $cur_file;
	    }
	}
    } elsif (exists $objsomething{$cur_file} &&
	     exists $ldso_dir{dirname($cur_file)} &&
	     exists $sharedobject{$cur_file}) {
	tag "sharedobject-in-library-directory-not-actually-a-shlib", "$cur_file";
    }
}

close(IN);

# 3rd step: check if shlib symlinks are present and in correct order
for my $shlib_file (keys %SONAME) {
    # file found?
    if (not exists $index_info{$shlib_file}) {
	fail("shlib $shlib_file not found in package (should not happen!)");
    }

    my ($dir, $shlib_name) = $shlib_file =~ m,(.*)/([^/]+)$,;

    # not a public shared library, skip it
    next unless defined $ldso_dir{$dir};

    # symlink found?
    my $link_file = "$dir/$SONAME{$shlib_file}";
    if (not exists $index_info{$link_file}) {
	tag "ldconfig-symlink-missing-for-shlib", "$link_file $shlib_file $SONAME{$shlib_file}";
    } else {
	# $link_file really another file?
	if ($link_file eq $shlib_file) {
	    # the library file uses its SONAME, this is ok...
	} else {
	    # $link_file really a symlink?
	    if (exists $link_info{$link_file}) {
		# yes.

		# $link_file pointing to correct file?
		if ($link_info{$link_file} eq $shlib_name) {
		    # ok.
		} else {
		    tag "ldconfig-symlink-referencing-wrong-file", "$link_file -> $link_info{$link_file} instead of $shlib_name";
		}
	    } else {
		tag "ldconfig-symlink-is-not-a-symlink", "$shlib_file $link_file";
	    }

	    # symlink after shlib?
	    if ($index_info{$link_file} < $index_info{$shlib_file}) {
		tag "ldconfig-symlink-before-shlib-in-deb", "$link_file";
	    }
	}
    }

    # determine shlib link name (w/o version)
    $link_file =~ s/\.so.*$/.so/o;

    # -dev package?
    if ($pkg =~ m/\-dev$/o) {
	# yes!!

	# need shlib symlink
	if (not exists $index_info{$link_file}) {
	    tag "dev-pkg-without-shlib-symlink", "$shlib_file $link_file";
	}
    } else {
	# no.

	# shlib symlink may not exist.
	# if shlib doesn't _have_ a version, then $link_file and $shlib_file will
	# be equal, and it's not a development link, so don't complain.
	if (exists $index_info{$link_file} and $link_file ne $shlib_file) {
	    tag "non-dev-pkg-with-shlib-symlink", "$shlib_file $link_file";
	}
    }
}

# 4th step: check shlibs control file
@shlibs = keys %SONAME;
if ($#shlibs == -1) {
    # no shared libraries included in package, thus shlibs control file should
    # not be present
    if (-f $shlibs_control_file) {
	tag "pkg-has-shlibs-control-file-but-no-actual-shared-libs", "";
    }
} else {
    # shared libraries included, thus shlibs control file has to exist
    if (not -f $shlibs_control_file) {
	if ($type ne 'udeb') {
	    for my $shlib (@shlibs) {
		# skip it if it's not a public shared library
		next unless defined $ldso_dir{dirname($shlib)};
		tag "no-shlibs-control-file", "$shlib";
	    }
	}
    } else {
	my %shlibs_control_used;
	my %shlibs_control;
	open(SHLIBS,$shlibs_control_file) or fail("cannot open shlibs control file $shlibs_control_file for reading: $!");
	while (<SHLIBS>) {
	    chop;
	    next if m/^\s*$/ or /^#/;
	    @words = split(/\s+/o,$_);
	    if ($shlibs_control{$words[0]}) {
		tag "duplicate-entry-in-shlibs-control-file", "$words[0]";
	    } else {
		$shlibs_control{$words[0]} = 1;
	    }
	}
	close(SHLIBS);
	my $shlib_name; 
	for my $shlib (@shlibs) {
	    $shlib_name = $SONAME{$shlib};
	    # libfoo.so.X.X
	    if ($shlib_name =~ m/(.+)\.so\..*$/) {
		$shlib_name = $1;
	    # libfoo-X.X.so
	    } elsif ($shlib_name =~ m/(.+)\-\w[\w\.]*\.so$/) {
		$shlib_name = $1;
	    }
	    if (exists $shlibs_control{$shlib_name}) {
		# ok, have entry in shlibs control file
		$shlibs_control_used{$shlib_name} = 1;
	    } else {
		# skip it if it's not a public shared library
 		next unless defined $ldso_dir{dirname($shlib)};
		# no!!
		tag "shlib-missing-in-control-file", "$shlib_name $shlib";
	    }
	}
	for $shlib_name (keys %shlibs_control) {
	    tag "unused-shlib-entry-in-control-file", "$shlib_name"
		unless $shlibs_control_used{$shlib_name};
	}
    }
}

# 5th step: check pre- and post- control files
if (-f $preinst) {
    local $_ = slurp_entire_file($preinst);
    if (/^[^\#]*\bldconfig\b/m) {
	tag "preinst-calls-ldconfig", ""
    }
}

if (-f $postinst) {
    local $_ = slurp_entire_file($postinst);

    # Decide if we call ldconfig
    if (/^[^\#]*\bldconfig\b/m) {
	tag "postinst-has-useless-call-to-ldconfig", ""
	    unless $must_call_ldconfig;
    } else {
	tag "postinst-must-call-ldconfig", "$must_call_ldconfig"
	    if $must_call_ldconfig;
    }
}

if (-f $prerm) {
    local $_ = slurp_entire_file($prerm);
    if (/^[^\#]*\bldconfig\b/m) {
	tag "prerm-calls-ldconfig", "";
    }
}

if (-f $postrm) {
    local $_ = slurp_entire_file($postrm);

    # Decide if we call ldconfig
    if (/^[^\#]*\bldconfig\b/m) {
	tag "postrm-has-useless-call-to-ldconfig", ""
	    unless $must_call_ldconfig;
    } else {
	tag "postrm-should-call-ldconfig", "$must_call_ldconfig"
	    if $must_call_ldconfig;
    }

    # Decide if we do it safely
    s/\bldconfig\b/BldconfigB/g;
    s/[ \t]//g;
    # this one matches code from debhelper
    s/^if\["\$1"=.?remove.?\];?\n*then\n*BldconfigB//gm;
    # variations...
    s/^if\[.?remove.?="\$1"\];?\n*then\n*BldconfigB//gm;
    s/^\["\$1"=.?remove.?\]\&&BldconfigB//gm;
    s/^\[.?remove.?="\$1"\]&&BldconfigB//gm;

	s!remove(?:|[^)]+)*\).*?BldconfigB.*?(;;|esac)!!s;

    if (/^[^\#]*BldconfigB/m) {
        tag "postrm-unsafe-ldconfig", "";
    }
}

}

# translate permission strings like `-rwxrwxrwx' into an octal number
sub perm2oct {
    my ($t) = @_;

    my $o = 0;

    $t =~ m/^.(.)(.)(.)(.)(.)(.)(.)(.)(.)/o;

    $o += 04000 if $3 eq 's';	# set-uid
    $o += 02000 if $6 eq 's';	# set-gid
    $o += 01000 if $9 eq 't';	# sticky bit
    $o += 00400 if $1 ne '-';	# owner read
    $o += 00200 if $2 ne '-';	# owner write
    $o += 00100 if $3 ne '-';	# owner execute
    $o += 00040 if $4 ne '-';	# owner read
    $o += 00020 if $5 ne '-';	# owner write
    $o += 00010 if $6 ne '-';	# owner execute
    $o += 00004 if $7 ne '-';	# owner read
    $o += 00002 if $8 ne '-';	# owner write
    $o += 00001 if $9 ne '-';	# owner execute

    return $o;
}

# make /tmp/baz/baz.txt from /tmp/foo/../bar/../baz/baz.txt
sub abs_path {
    my $path = shift;
    while($path =~ s!/[^/]*/\.\./!/!g){1};
    return $path;
}

1;

# vim: syntax=perl sw=4 ts=8
