#!/usr/bin/perl -w
# list-binpkg -- lintian helper script

# Copyright (C) 1998 Christian Schwarz
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, you can find it on the World Wide
# Web at http://www.gnu.org/copyleft/gpl.html, or write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

use strict;
use warnings;

use lib "$ENV{'LINTIAN_ROOT'}/lib";
use Lintian::Lab::Manifest;
use Lintian::Relation::Version qw(versions_lte);
use Util;

# turn file buffering off:
$| = 1;

# parse command line options
if ($#ARGV == -1) {
    print "list-binpkg [-v] <output-list-file>\n";
    print "options:\n";
    print "   -v  verbose\n";
    print "   -u  Fetch udebs\n";
    exit 0;
}

my $verbose = 0;
my $udeb = 0;
my $output_file = undef;
my $type = 'binary';

while (my $arg = shift) {
    if ($arg =~ s,^-,,o) {
        if ($arg eq 'v') {
            $verbose = 1;
        } elsif ($arg eq 'u') {
            $udeb = 1;
            $type = 'udeb';
        } else {
            print STDERR "error: unknown command line argument: $arg\n";
            exit 1;
        }
    } else {
        if ($output_file) {
            print STDERR "error: too many command line arguments: $arg\n";
            exit 1;
        }
        $output_file = $arg;
    }
}

unless ($output_file) {
    print STDERR "error: no output file specified\n";
    exit 1;
}



# get variables out of environment
my $LINTIAN_ARCHIVEDIR = $ENV{'LINTIAN_ARCHIVEDIR'};
my $LINTIAN_DIST = $ENV{'LINTIAN_DIST'};
my $LINTIAN_ARCH = $ENV{'LINTIAN_ARCH'};
my $LINTIAN_AREA = $ENV{'LINTIAN_AREA'};
my $LINTIAN_LAB = $ENV{'LINTIAN_LAB'};

# read old list file (this command does nothing if the file does not exist)
my $plist = Lintian::Lab::Manifest->new ($type);
# This stores all the new ones (allows us to use $plist to find old entries)
my $nlist = Lintian::Lab::Manifest->new ($type);
# ignore the contents if the contents cannot be read - that is what we
# used to do!
eval { $plist->read_list($output_file) };

my %pkgfile;
# map filenames to package keys (so we can look them up later)
$plist->visit_all (sub {
    my ($v, @k) = @_;
    $pkgfile{$v->{'file'}} = \@k;
});

# parse Packages file to get list of packages
my @packages_files;
foreach my $area (split /\s*,\s*/,$LINTIAN_AREA) {
    my %hash;
    my $file;
    $hash{'dist'} = $LINTIAN_DIST;
    $hash{'arch'} = $LINTIAN_ARCH;
    $hash{'area'} = $area;
    if ($udeb) {
        $file = "$LINTIAN_ARCHIVEDIR/dists/$hash{'dist'}/$hash{'area'}/" .
                "debian-installer/binary-$hash{'arch'}/Packages";
    } else {
        $file = "$LINTIAN_ARCHIVEDIR/dists/$hash{'dist'}/$hash{'area'}/" .
                "binary-$hash{'arch'}/Packages";
    }
    $hash{'file'} = $file;
    push @packages_files, \%hash;
}

my $total = 0;
my @status_list;

foreach my $packages_file (@packages_files) {
    my $pkgs_file = $packages_file->{'file'};
    if (-e $pkgs_file) {
        print "N: Parsing $pkgs_file ...\n" if $verbose;
        open(IN, '<', $pkgs_file)
            or fail("cannot open Packages file $pkgs_file: $!");
    } elsif (-e "$pkgs_file.gz") {
        print "N: Parsing $pkgs_file.gz ...\n" if $verbose;
        open (IN, '-|', 'gzip', '-dc', "$pkgs_file.gz")
            or fail("cannot open Packages file $pkgs_file.gz: $!");
    } else {
        fail("No packages file $pkgs_file");
    }

    my $line;

    while (!eof(IN)) {
        my ($arch, $deb_file);
        do {
            $line = <IN>;
            if ($line =~ /^Architecture: (.*)$/m) {
                $arch = $1;
            } elsif ($line =~ /^Filename: (.*)$/m) {
                $deb_file = $1;
            }
        } until (not defined($line) or $line =~ /^\s*$/m);

        my @stat;
        # get timestamp...
        unless (@stat = stat "$LINTIAN_ARCHIVEDIR/$deb_file") {
            print "E: general: cannot stat $LINTIAN_ARCHIVEDIR/$deb_file\n";
            next;
        }
        my $timestamp = $stat[9];
        my ($status, $data);
        my @keys;

        # was package already included in last list?
        if (exists $pkgfile{$deb_file}) {
            # yes!
            @keys = @{ $pkgfile{$deb_file} };
            $data = $plist->get (@keys);

            # file changed since last run?
            if ($timestamp == $data->{'timestamp'}) {
                # no.
                $status = 'unchanged';
            } else {
                $status = 'changed';
                $plist->delete (@keys);
            }
        } else {
            # new package, get info
            $status = 'new';
        }

        if (($status eq 'new') or ($status eq 'changed')) {
            $data = &safe_get_deb_info ($deb_file);
            next if not defined $data;
            @keys = ($data->{'package'}, $data->{'version'}, $data->{'architecture'});
        }

        unless (exists $data->{'source-version'}) {
            if ($data->{'source'} =~ /^([-+\.\w]+)\s+\((.+)\)$/) {
                $data->{'source'} = $1;
                $data->{'source-version'} = $2;
            } else {
                $data->{'source-version'} = $data->{'version'};
            }
        }

        # Save entry for writing to output file.
        $data->{file} = $deb_file;
        $data->{timestamp} = $timestamp;
        $data->{area} = $packages_file->{area};
        push @status_list, [$status, @keys];
        $nlist->set ($data);

        # remove record
        plist->delete (@keys) if $status eq 'unchanged';
        $total++;
    }
    close(IN) or fail("cannot close input pipe: $!");
}
$nlist->write_list($output_file);

if ($verbose) {
    foreach my $status (@status_list) {
        print "N: Listed %s $type package %s %s %s\n", @$status;
    }

    # All packages that are still included in $plist have disappeared
    # from the archive.
    $plist->visit_all (sub { print "N: Removed $type $_[1] $_[2] $_[3] from list\n" });
    printf "N: Listed %d $type packages\n",$total;
}

exit 0;

sub safe_get_deb_info {
    # use eval when calling get_deb_info, since we don't want to `die' just
    # because of a single broken package
    my $data;
    eval { $data = get_deb_info("$LINTIAN_ARCHIVEDIR/$_[0]"); };
    if ($@) {
        # error!
        print STDERR "$@\n";
        print "E: general: bad-$type-package $_[0]\n";
        return;
    }
    $data->{'source'} or ($data->{'source'} = $data->{'package'});
    return $data;
}

# Local Variables:
# indent-tabs-mode: nil
# cperl-indent-level: 4
# End:
# vim: syntax=perl sw=4 sts=4 sr et
